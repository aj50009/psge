#ifndef __PSGE_H__
#define __PSGE_H__

#define DISC_SECTOR_SIZE 2048

#define MEMCARD_CHANNEL_A 0x00
#define MEMCARD_CHANNEL_B 0x10

#define MEMCARD_STATUS_CONNECTED 0x00
#define MEMCARD_STATUS_NOT_CONNECTED 0x01
#define MEMCARD_STATUS_INVALID 0x02
#define MEMCARD_STATUS_NEW_CARD 0x03
#define MEMCARD_STATUS_UNFORMATTED 0x04
#define MEMCARD_STATUS_NOT_FOUND 0x05
#define MEMCARD_STATUS_ALREADY_EXISTS 0x06
#define MEMCARD_STATUS_MEMORY_FULL 0x07

#define MEMCARD_NAME_FILTER_ALL "*"

#define MEMCARD_BLOCK_SIZE 8192
#define MEMCARD_MAX_BLOCKS 15

#define MEMCARD_FILE_NAME_LENGTH 20

#define MEMCARD_MODE_READ 0x0001
#define MEMCARD_MODE_WRITE 0x0002
#define MEMCARD_MODE_BOTH (MEMCARD_MODE_READ | MEMCARD_MODE_WRITE)

#define MEMCARD_TYPE_1_FRAME 0x11
#define MEMCARD_TYPE_2_FRAMES 0x12
#define MEMCARD_TYPE_3_FRAMES 0x13

#define MEMCARD_TITLE_MAX_LENGTH 64

#define MEMCARD_TIM4BPP_CLUT(x) ((unsigned char*)x + 20)
#define MEMCARD_TIM4BPP_IMAGE(x) ((unsigned char*)x + 64)

#define CONTROLLER_A 0x00
#define CONTROLLER_A_MTAP_A 0x00
#define CONTROLLER_A_MTAP_B 0x01
#define CONTROLLER_A_MTAP_C 0x02
#define CONTROLLER_A_MTAP_D 0x03
#define CONTROLLER_B 0x10
#define CONTROLLER_B_MTAP_A 0x10
#define CONTROLLER_B_MTAP_B 0x11
#define CONTROLLER_B_MTAP_C 0x12
#define CONTROLLER_B_MTAP_D 0x13

#define CONTROLLER_STATE_NOT_CONNECTED 0x00
#define CONTROLLER_STATE_CONNECTED 0x06

/** Represents data on heap. */
typedef struct {
	/** Pointer to data on heap. */
	unsigned char* data;
	/** Data lenegth in bytes. */
	unsigned int length;
	/** Pointer to raw data on heap. This pointer may not equal data pointer, depending on sector offset calculated in {@link psReadFileDisc}. */
	unsigned char* raw_data;
	/** Number of sectors read in total. This value is 0 if data was not generated by {@link psReadFileDisc}. */
	unsigned int sector_count;
} psDATA;

/** Represents memory card entry information. */
typedef struct {
	/** Memory card entry name. */
	char name[MEMCARD_FILE_NAME_LENGTH];
	/** Number of blocks occupied by the memory card entry. */
	unsigned char block_count;
} psMEMCARDINFO;

/** Represents memory card entry header information. */
typedef struct {
	/** Magic number. Should always be 'S' and 'C'. */
	unsigned char magic_number[2];
	/** Type of the save entry. Can be MEMCARD_TYPE_1_FRAME, MEMCARD_TYPE_2_FRAMES or MEMCARD_TYPE_3_FRAME. */
	unsigned char type;
	/** Number of blocks occupied by the save file. Must be between 1 and 15. */
	unsigned char block_count;
	/** Title of the save encoded in Shift-JIS. */
	unsigned char title_shift_jis[MEMCARD_TITLE_MAX_LENGTH];
	/** Padding in the save file. This area can be ignored. */
	unsigned char pad[28];
	/** Color lookup table for all of the three icons of the save file entry. Image quality is 4BPP (4 bits per pixel). */
	unsigned char clut[32];
	/** First icon. Dimensions are 16x16 pixels. */
	unsigned char image1[128];
	/** Second icon. Dimensions are 16x16 pixels. */
	unsigned char image2[128];
	/** Third icon. Dimensions are 16x16 pixels. */
	unsigned char image3[128];
} psMEMCARDHEADER;

/**
 * Initializes PSGE libraries. This function must be called before any other function.
 */
extern void psInit();

/**
 * Searches for file on disc and initiates reading part of it to memory. To make sure that the data is fully read, use {@link psWaitDisc}.
 * @param filename Full path to file to be read.
 * @param offset Amount of bytes to skip from the beginning of the file.
 * @param length Amount of bytes to read from the file. If length is 0, file will be read to end.
 * @return Read data as {@link psDATA}. Use {@link psWaitDisc} to make sure that disc reading is done.
 * @see psWaitDisc
 */
extern psDATA* psReadFileDisc(char* filename, unsigned int offset, unsigned int length);

/**
 * Checks whether disc reading has completed.
 * @return If reading has not completed, number of remining sectors to be read is returned. Otherwise 0 is returned if previous reading was successful and -1 is returned if it failed.
 * @see psReadFileDisc
 */
extern int psWaitDisc();

/**
 * Allocates memory on heap.
 * @param length Amount of bytes to allocate.
 * @return Allocated memory as {@link psDATA}. If an error occurs (i.e. insufficient memory on heap), NULL is returned.
 */
extern psDATA* psAllocateData(unsigned int length);

/**
 * Clears part of data with a predefined byte value. Note that all preceding and following data (usually caused by reading from file on disc) will be ignored.
 * @param data Data to be cleared.
 * @param value Predefined byte value to clear the data with.
 * @param offset Amount of bytes to skip from the beginning of the data.
 * @param length Amount of bytes to clear. If length is 0, data will be cleared to end.
 */
extern void psClearData(psDATA* data, unsigned char value, unsigned int offset, unsigned int length);

/**
 * Makes copy of heap data. Note that all preceding and following data (usually caused by reading from file on disc) will be ignored.
 * @param data Data to be copied.
 * @param offset Amount of bytes to leave out from the beginning of the data.
 * @param length Amount of bytes to copy from the data. If length is 0, data will be copied to end.
 * @return Copied data as {@link psDATA}. If an error occurs (i.e. insufficient memory on heap), NULL is returned.
 */
extern psDATA* psCopyData(psDATA* data, unsigned int offset, unsigned int length);

/**
 * Frees allocated memory from heap.
 * @param data Data to be freed from heap.
 */
extern void psFreeData(psDATA* data);

/**
 * Checks memory card status.
 * @param channel Memory card channel to be checked. Can be MEMCARD_CHANNEL_A or MEMCARD_CHANNEL_B.
 * @return Status of the memory card. Can be MEMCARD_STATUS_CONNECTED, MEMCARD_STATUS_NOT_CONNECTED, MEMCARD_STATUS_INVALID, MEMCARD_STATUS_NEW_CARD or MEMCARD_STATUS_UNFORMATTED.
 * @see psStartMemCardMode
 * @see psStopMemCardMode
 */
extern int psCheckMemCardStatus(int channel);

/**
 * Formats a memory card.
 * @param channel Memory card channel to be formatted. Can be MEMCARD_CHANNEL_A or MEMCARD_CHANNEL_B.
 * @return Status of the memory card after completion. Can be MEMCARD_STATUS_CONNECTED, MEMCARD_STATUS_NOT_CONNECTED or MEMCARD_STATUS_INVALID.
 * @see psStartMemCardMode
 * @see psStopMemCardMode
 */
extern int psFormatMemCard(int channel);

/**
 * Checks memory card for entries.
 * @param channel Memory card channel to be checked. Can be MEMCARD_CHANNEL_A or MEMCARD_CHANNEL_B.
 * @param file_filter Entry names to be checked. Wildcards are supported ('?' and '*'). You can also use MEMCARD_NAME_FILTER_ALL.
 * @param out_info An array into which the result will be stored if the function completes successfully.
 * @param max_info Size of the output array.
 * @return Status of the memory card after completion. Can be MEMCARD_STATUS_CONNECTED, MEMCARD_STATUS_NOT_CONNECTED or MEMCARD_STATUS_INVALID.
 * @see psStartMemCardMode
 * @see psStopMemCardMode
 */
extern int psCheckMemCardInfo(int channel, char* file_filter, psMEMCARDINFO* out_info, int max_info);

/**
 * Creates a new memory card save.
 * @param channel Memory card channel to be used. Can be MEMCARD_CHANNEL_A or MEMCARD_CHANNEL_B.
 * @param file_name Name of the new memory card entry (20 characters max, including null terminator). Should follow a convention for save file names. First character is always 'B', then the second is the code of the region (Japan is 'I', North America is 'A' and Europe is 'E'), then the product code (e.g. SLPS-00001) and the rest of the string is optional. Example of a save file name is BISLPS-00001XYZ.
 * @param block_count Amount of blocks to occupy. Each block is 8192 bytes long. This value ranges from 1 to 15 blocks.
 * @return Status of the memory card after completion. Can be MEMCARD_STATUS_CONNECTED, MEMCARD_STATUS_NOT_CONNECTED, MEMCARD_STATUS_INVALID, MEMCARD_STATUS_UNFORMATTED, MEMCARD_STATUS_ALREADY_EXISTS or MEMCARD_STATUS_MEMORY_FULL.
 * @see psStartMemCardMode
 * @see psStopMemCardMode
 */
extern int psCreateMemCardSave(int channel, char* file_name, unsigned char block_count);

/**
 * Deletes an existing memory card save.
 * @param channel Memory card channel to be used. Can be MEMCARD_CHANNEL_A or MEMCARD_CHANNEL_B.
 * @param file_name Name of an existing memory card save.
 * @return Status of the memory card after completion. Can be MEMCARD_STATUS_CONNECTED, MEMCARD_STATUS_NOT_CONNECTED, MEMCARD_STATUS_INVALID, MEMCARD_STATUS_UNFORMATTED or MEMCARD_STATUS_NOT_FOUND.
 * @see psStartMemCardMode
 * @see psStopMemCardMode
 */
extern int psDeleteMemCardSave(int channel, char* file_name);

/**
 * Converts ASCII string to Shift-JIS string.
 * @param src Source ASCII string.
 * @param dest Destination Shift-JIS string.
 * @param max_length Max length of the Shift-JIS string (in bytes).
 * @return If conversion was successful, 0 is returned. Otherwise, 1 is returned.
 */
extern int psASCIIToShiftJIS(char* src, unsigned char* dest, unsigned int max_length);

/**
 * Converts Shift-JIS string to ASCII string.
 * @param src Source Shift-JIS string.
 * @param dest Destination ASCII string.
 * @param max_length Max length of the ASCII string (in bytes).
 * @return If conversion was successful, 0 is returned. Otherwise, 1 is returned.
 */
extern int psShiftJISToASCII(unsigned char* src, char* dest, unsigned int max_length);

/**
 * Opens memory card save file so that data can be read or written.
 * @param channel Memory card channel to be used. Can be MEMCARD_CHANNEL_A or MEMCARD_CHANNEL_B.
 * @param file_name Name of the memory card save file.
 * @param mode Specifies mode for opening the file. Can be MEMCARD_MODE_READ, MEMCARD_MODE_WRITE or MEMCARD_MODE_BOTH.
 * @return Status of the memory card after completion. Can be MEMCARD_STATUS_CONNECTED, MEMCARD_STATUS_NOT_CONNECTED, MEMCARD_STATUS_INVALID, MEMCARD_STATUS_UNFORMATTED or MEMCARD_STATUS_NOT_FOUND.
 * @see psCloseMemCardSave
 * @see psStartMemCardMode
 * @see psStopMemCardMode
 */
extern int psOpenMemCardSave(int channel, char* file_name, int mode);

/**
 * Closes the previously opened memory card save file.
 * @see psOpenMemCardSave
 * @see psStartMemCardMode
 * @see psStopMemCardMode
 */
extern void psCloseMemCardSave();

/**
 * Generates a new memory card save header {@link psMEMCARDHEADER}.
 * @param out_header Output for the generated header.
 * @param type Save file entry type. Can be MEMCARD_TYPE_1_FRAME, MEMCARD_TYPE_2_FRAMES or MEMCARD_TYPE_3_FRAMES.
 * @param block_count Number of blocks occupied by the save file. Must be between 1 and 15.
 * @param title_shift_jis Title of the save encoded in Shift-JIS. This value should be null terminated and cannot be longer than 64 bytes. For conversion, you can use {@link psASCIIToShiftJIS} and {@link psShiftJISToASCII}.
 * @param clut Color lookup table for the images. It is 32 bytes long. You can use MEMCARD_TIM4BPP_CLUT(x) macro to generate it from loaded TIM file.
 * @param image1 First image of the memory card save icon. It is 128 bytes long. You can use MEMCARD_TIM4BPP_IMAGE(x) macro to generate it from loaded TIM file.
 * @param image2 Second image of the memory card save icon. It is 128 bytes long. You can set this to NULL if type is MEMCARD_TYPE_1_FRAME. You can use MEMCARD_TIM4BPP_IMAGE(x) macro to generate it from loaded TIM file.
 * @param image3 Third image of the memory card save icon. It is 128 bytes long. You can set this to NULL if type is MEMCARD_TYPE_1_FRAME or MEMCARD_TYPE_2_FRAMES. You can use MEMCARD_TIM4BPP_IMAGE(x) macro to generate it from loaded TIM file.
 * @return If generation was successful, 0 is returned. Otherwise, 1 is returned.
 */
extern int psGenerateMemCardHeader(psMEMCARDHEADER* out_header, unsigned char type, unsigned char block_count, unsigned char* title_shift_jis, unsigned char* clut, unsigned char* image1, unsigned char* image2, unsigned char* image3);

/**
 * Writes data to the memory card save entry. Save file must be previously opened with {@link psOpenMemCardSave}.
 * @param data Pointer to a data buffer.
 * @param offset Offset from the beginning of the save file in bytes. Offset is defined in bytes, and must be a multiple of 128. First 256, 384 or 512 bytes (depending on type) of every file is the header {@link psMEMCARDHEADER}.
 * @param length Amount of bytes to write to the file. Must be a multiple of 128.
 * @return Status of the memory card after completion. Can be MEMCARD_STATUS_CONNECTED, MEMCARD_STATUS_NOT_CONNECTED, MEMCARD_STATUS_INVALID or MEMCARD_STATUS_NEW_CARD.
 * @see psStartMemCardMode
 * @see psStopMemCardMode
 */
extern int psWriteMemCardData(unsigned char* data, unsigned int offset, unsigned int length);

/**
 * Reads data from the memory card save entry. Save file must be previously opened with {@link psOpenMemCardSave}.
 * @param data Pointer to a data buffer.
 * @param offset Offset from the beginning of the save file in bytes. Offset is defined in bytes, and must be a multiple of 128. First 256, 384 or 512 bytes (depending on type) of every file is the header {@link psMEMCARDHEADER}.
 * @param length Amount of bytes to read from the file. Must be a multiple of 128.
 * @return Status of the memory card after completion. Can be MEMCARD_STATUS_CONNECTED, MEMCARD_STATUS_NOT_CONNECTED, MEMCARD_STATUS_INVALID or MEMCARD_STATUS_NEW_CARD.
 * @see psStartMemCardMode
 * @see psStopMemCardMode
 */
extern int psReadMemCardData(unsigned char* data, unsigned int offset, unsigned int length);

/**
 * Enters memory card mode. Use this before any of the other memory card functions. When you are in memory card mode, controllers will be disabled.
 * @see psStopMemCardMode
 */
extern void psStartMemCardMode();

/**
 * Exits memory card mode. Reactivates controllers.
 * @see psStartMemCardMode
 */
extern void psStopMemCardMode();

/**
 * Gets the state of the controller.
 * @param port Controller port to check. Can be CONTROLLER_A, CONTROLLER_A_MTAP_A, CONTROLLER_A_MTAP_B, CONTROLLER_A_MTAP_C, CONTROLLER_A_MTAP_D, CONTROLLER_B, CONTROLLER_B_MTAP_A, CONTROLLER_B_MTAP_B, CONTROLLER_B_MTAP_C or CONTROLLER_B_MTAP_D.
 * State of the controller. Can be ...
 */
extern int psGetControllerState(int port);

#endif
